#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Input:: *)
(*(*define model*)*)
(*jX=(jXm X)/(X+KX); *)
(* jN=(jNm \[CapitalNu])/(\[CapitalNu]+KN); *)
(*jHT=j0HT; *)
(*rNH=\[Sigma]NH nNH jHT; *)
(*rNS1=\[Sigma]NS1 nNS1 j0ST1; *)
(*rNS2=\[Sigma]NS2 nNS2 j0ST2; *)
(*jX=(jXm X)/(X+KX); *)
(* jN=(jNm \[CapitalNu])/(\[CapitalNu]+KN); *)
(*A=1.256307+1.385969 E^(-6.479055 (S1 + S2)/H); *)
(*(*SU*)*)
(*F[\[Rho]_][A_,B_]:=(A B (A+B) \[Rho])/(A^2 B+A B^2+A^2 \[Rho]+A B \[Rho]+B^2 \[Rho]);*)
(*(*full set of fluxes*)*)
(*tsolve={*)
(*{jHG,F[jHGm][yC (\[Rho]C1 S1/H + \[Rho]C2 S2/H+jX),(jN+nNX jX+rNH)nNH^-1]}, *)
(*{\[Rho]N,jN+nNX jX+rNH-nNH jHG yN^-1}, (* yep-ish, need to remove yN, I think *)*)
(*{jeC,jX+\[Rho]C1 S1/H + \[Rho]C2 S2/H-jHG yC^-1}, *)
(*{jCO2,kCO2 jeC}, *)
(*{jL1,A L astar1},*)
(*{jL2,A L astar2},*)
(*{rCH,\[Sigma]CH(jHT+(1-yC)jHG yC^-1)}, *)
(*{rCS1,\[Sigma]CS1(j0ST1+(1-yC)jSG1 yC^-1)},*)
(*{rCS2,\[Sigma]CS2(j0ST2+(1-yC)jSG2 yC^-1)},*)
(*{jCP1,F[jCPm1][yCL1 jL1,(jCO2+rCH) H/(S1 + S2)+rCS1](cROS11+1)^-1},*)
(*{jCP2,F[jCPm2][yCL2 jL2,(jCO2+rCH) H/(S1 + S2)+rCS2](cROS12+1)^-1},*)
(*{jeL1,jL1-jCP1 yCL1^-1},*)
(*{jeL2,jL2-jCP2 yCL2^-1},*)
(*{jNPQ1,(kNPQ1^-1+jeL1^-1)^-1},*)
(*{jNPQ2,(kNPQ2^-1+jeL2^-1)^-1},*)
(*{cROS11,(jeL1-jNPQ1)/kROS1},*)
(*{cROS12,(jeL2-jNPQ2)/kROS2},*)
(*{jSG1,F[jSGm1][yC jCP1,(\[Rho]N H/(S1 + S2)+rNS1)nNS1^-1]},*)
(*{jSG2,F[jSGm2][yC jCP2,(\[Rho]N H/(S1 + S2)+rNS2)nNS2^-1]},*)
(*{\[Rho]C1,jCP1-jSG1 yC^-1}, *)
(*{\[Rho]C2,jCP2-jSG2 yC^-1}, *)
(*{jST1,j0ST1(1+b1 cROS11)}, *)
(*{jST2,j0ST2(1+b2 cROS12)} *)
(*};*)
(*(*names of fluxes*)*)
(*names={jHG->"\!\(\*SubscriptBox[\(j\), \(HG\)]\)",\[Rho]N->"\!\(\*SubscriptBox[\(\[Rho]\), \(N\)]\)",jeC->"\!\(\*SubscriptBox[\(j\), \(eC\)]\)",jCO2->"\!\(\*SubscriptBox[\(j\), SubscriptBox[\(CO\), \(2\)]]\)",jL1->"\!\(\*SubscriptBox[\(j\), \(L1\)]\)",jL2->"\!\(\*SubscriptBox[\(j\), \(L2\)]\)",rCH->"\!\(\*SubscriptBox[\(r\), \(CH\)]\)",rCS1->"\!\(\*SubscriptBox[\(r\), \(CS1\)]\)",*)
(*rCS2->"\!\(\*SubscriptBox[\(r\), \(CS2\)]\)",jCP1->"\!\(\*SubscriptBox[\(j\), \(CP1\)]\)",jCP2->"\!\(\*SubscriptBox[\(j\), \(CP2\)]\)",jeL1->"\!\(\*SubscriptBox[\(j\), \(eL1\)]\)",jeL2->"\!\(\*SubscriptBox[\(j\), \(eL2\)]\)",jNPQ1->"\!\(\*SubscriptBox[\(j\), \(NPQ1\)]\)", jNPQ2->"\!\(\*SubscriptBox[\(j\), \(NPQ2\)]\)",cROS11->"\!\(\*SubscriptBox[\(c\), \(ROS1\)]\)"(*"Subscript[c, ROS1]-1"*), cROS12->"\!\(\*SubscriptBox[\(c\), \(ROS2\)]\)"(*"Subscript[c, ROS2]-1"*), jSG1->"\!\(\*SubscriptBox[\(j\), \(SG1\)]\)",jSG2->"\!\(\*SubscriptBox[\(j\), \(SG2\)]\)",\[Rho]C1->"\!\(\*SubscriptBox[\(\[Rho]\), \(C1\)]\)",\[Rho]C2->"\!\(\*SubscriptBox[\(\[Rho]\), \(C2\)]\)",jST1->"\!\(\*SubscriptBox[\(j\), \(ST1\)]\)", jST2->"\!\(\*SubscriptBox[\(j\), \(ST2\)]\)"};*)
(*(*helper functions*)*)
(*numbers[tsolve_]:=Transpose[{Range@Length@#,#}]&@tsolve[[All,1]];*)
(*fluxtonumber[tsolve_]:=#[[2]]->#[[1]]&/@numbers[tsolve];*)
(*getnumbers[tsolve_,fluxes_]:=Select[numbers[tsolve],MemberQ[fluxes,#[[2]]]&][[All,1]];*)
(*reduce[tsolve_,numbers_]:=Delete[tsolve,{#}&/@numbers];*)
(*(*get the adjency matrix fromt the fluxes in tsolve*)*)
(*matrix[tsolve_]:=matrix[tsolve]=Table[Table[FreeQ[row[[2]],x],{row,tsolve}],{x,tsolve[[All,1]]}]/.{True->0,False->1};*)


(* ::Input:: *)
(*(*show the adjacency matrix*)*)
(*TableForm[matrix[tsolve],TableHeadings->{#,#}&@(tsolve[[All,1]]/.names)]*)


(* ::Input:: *)
(*(*make a graph from the fluxes in tsolve (using the adjency matrix)*)*)
(*graph[tsolve_,markeds_]:=AdjacencyGraph[matrix[tsolve],VertexStyle->Table[i->\!\(\**)
(*TagBox[GridBox[{*)
(*{"\[Piecewise]", GridBox[{*)
(*{"Yellow", *)
(*RowBox[{"MemberQ", "[", *)
(*RowBox[{*)
(*RowBox[{"markeds", "/.", *)
(*RowBox[{"fluxtonumber", "[", "tsolve", "]"}]}], ",", "i"}], "]"}]},*)
(*{*)
(*RowBox[{"Lighter", "[", *)
(*RowBox[{*)
(*RowBox[{*)
(*RowBox[{"ColorData", "[", "97", "]"}], "[", "1", "]"}], ",", ".9"}], "]"}], "True"}*)
(*},*)
(*AllowedDimensions->{2, Automatic},*)
(*Editable->True,*)
(*GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},*)
(*GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},*)
(*GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},*)
(*Selectable->True]}*)
(*},*)
(*GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},*)
(*GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},*)
(*GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}],*)
(*"Piecewise",*)
(*DeleteWithContents->True,*)
(*Editable->False,*)
(*SelectWithContents->True,*)
(*Selectable->False,*)
(*StripWrapperBoxes->True]\),{i,Length@tsolve}],VertexSize->{{.13,.13}},VertexLabels->(#[[1]]->Placed[#[[2]],Center]&/@numbers[tsolve]/.names),VertexLabelStyle->Directive[5,Bold,Italic],ImageSize->500,EdgeStyle->{{Thickness[Scaled[.002]],Black}},GraphLayout->"SpringElectricalEmbedding"];*)
(*graph[tsolve,{}]*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*(*test if graph has no loops*)*)
(*GoodGraphQ:=AcyclicGraphQ[#]\[And]LoopFreeGraphQ[#]&;*)
(*(*get all possible flux combinations up to level*)*)
(*acycliccombinations[tsolve_,level_]:=Subsets[tsolve[[All,1]],level];*)
(*(*find all combinations with a given number of fluxes as state variables (maximally maxlevel) that make the graph having no cycles. Exclude redundant solutions (that just add state variables to lower level solutions)*)*)
(*maxlevel=5;*)
(*Clear[fluxsolutions];*)
(*Table[fluxsolutions[level]=Table[If[GoodGraphQ[graph[reduce[tsolve,getnumbers[tsolve,statefluxes]],{}]],statefluxes,Nothing],{statefluxes,Select[acycliccombinations[tsolve,{level}],If[level==0,True,And@@Table[Not@SubsetQ[#,lowersolution],{lowersolution,Flatten[Table[fluxsolutions[lowerlevel],{lowerlevel,0,level-1}],1]}]]&]}],{level,0,maxlevel}];*)


(* ::Input:: *)
(*(*(Export["fluxplots.pdf",#];#)&@*)Column[Join[{"Cycle-free versions of graph. Yellow: flux-state-variables that interrupt cycles.","Level = number of fluxes to replace with state variables","Do not show redundant solutions (that just add state variables to lower level solutions)"},Table[*)
(*Column[{"--------------",Row[{"Level: ",level}],*)
(*Column[Table[graph[tsolve,statefluxes],{statefluxes,fluxsolutions[level]}]]}],*)
(*{level,0,maxlevel}]]]*)
